{"Instruction": "Please implement the module barrett_red_opt_6(\ninput                          clk,\n  input                          rst_n,\n  input                          enable_p,\n  input  [2*NBITS-1 :0]          a,\n  input  [NBITS-1 :0]            m,\n  input  [$clog2(NBITS)+1:0]     k,\n  input  [$clog2(NBITS)  :0]     k_shft_ah,     // (k >> 1)  - 1\n  input  [$clog2(NBITS)  :0]     k_shft_ahxmd,  // (k >> 1)  + 1\n  input  [NBITS:0]               md,\n  input  [NBITS+1 :0]            mx3,\n  output reg                     done,\n  output reg [NBITS-1 :0]        y\n););", "Response": ["//---------------------------------------------------\n//Barrett Reduction:\n// For modulus Size n bits\n// a = x*y;  //2n bits\n//High level idea is : a mod m = a - m * floor(a/m) \n//Approximate 1/m to md/2^k ; k = 2*ceil(log2 modulus) =  2*n\n// md is n+1 bits\n// a mod m = a       - m      * (a*md/2^k)\n//Algo 1\n//         = a       - m      * (ah*2^(n-1)     + al)*md/2^2*n\n//         = a       - m      * (ah*2^(n-1)     + al)*md/2^2*n\n//         = a       - m      * (ah*md/2^(n+1)  + al*md/2^2*n)\n//         = 2n bits - n bits * (n+1 bits       + 0 bit)\n//         = a       - m      * (ah*md/2^(n+1))\n//---------------------------------------------------\n//Algo 2\n//         = a       - m      * (ah*2^(n)       + al)*md/2^2*n\n//         = a       - m      * (ah*2^(n)       + al)*md/2^2*n\n//         = a       - m      * (ah*md/2^(n)    + al*md/2^2*n)\n//         = 2n bits - n bits * (n+1 bits       + 1 bit)\n//         = a       - m      * (ah*md/2^(n)    + al*md/2^2*n)\n//---------------------------------------------------\n\nmodule barrett_red_opt_6  #(\n  parameter NBITS = 128,\n  parameter PBITS = 0\n\n ) (\n  input                          clk,\n  input                          rst_n,\n  input                          enable_p,\n  input  [2*NBITS-1 :0]          a,\n  input  [NBITS-1 :0]            m,\n  input  [$clog2(NBITS)+1:0]     k,\n  input  [$clog2(NBITS)  :0]     k_shft_ah,     // (k >> 1)  - 1\n  input  [$clog2(NBITS)  :0]     k_shft_ahxmd,  // (k >> 1)  + 1\n  input  [NBITS:0]               md,\n  input  [NBITS+1 :0]            mx3,\n  output reg                     done,\n  output reg [NBITS-1 :0]        y\n);\n\n\nwire [NBITS          :0] ah;\n\nwire [2*NBITS+1   :0]  ahxmd;\n\nwire  [NBITS :0]       ahxmd_shftd;\n\nreg done_nom_mul2_d;\n\nreg  [NBITS+1 :0]     y_red;\nreg  [NBITS+2 :0]     y_red_sub_m;\nreg  [NBITS+3 :0]     y_red_sub_mx2;\n\nassign ah     = a >> k_shft_ah;\n\nnom_mul_6_stage #(\n  .NBITS (NBITS+1),\n  .PBITS (PBITS)) u_mul_1_inst (\n   .clk           (clk),          //input                 \n   .rst_n         (rst_n),        //input                 \n   .enable_p      (enable_p),     //input                 \n   .a             (ah),\n   .b             (md),\n   .y             (ahxmd),\n   .done          (done_nom_mul1)      //output  reg           \n);\n\n\nlocalparam ALOCDEPTH = 10;\nreg  [2*NBITS-1   :0]  a_loc[ALOCDEPTH-1:0];\nalways @ (posedge clk or negedge rst_n) begin\n  if (rst_n == 1'b0) begin\n    a_loc[0] <= {2*NBITS{1'b0}};\n  end\n  else begin\n    if (enable_p == 1'b1) begin\n      a_loc[0] <= a;\n    end \n  end\nend\n\ngenvar i;\ngenerate \n  for (i=1; i < ALOCDEPTH; i=i+1) begin\n    always @ (posedge clk or negedge rst_n) begin\n      if (rst_n == 1'b0) begin\n        a_loc[i] <= {2*NBITS{1'b0}};\n      end\n      else begin\n          a_loc[i] <= a_loc[i-1];\n      end\n    end\n  end\nendgenerate\n\n\n\n//bit size of y_loc       = 3*NBITS\n//bit size of ahxmd_shftd = 2*NBITS\n\nassign  ahxmd_shftd = ahxmd >> k_shft_ahxmd;\n\nwire [2*NBITS :0]  shftdXm;\nnom_mul_6_stage #(\n  .NBITS ((1 + NBITS)),\n  .PBITS (PBITS)) u_mul2_inst (\n   .clk           (clk),          //input                 \n   .rst_n         (rst_n),        //input                 \n   .enable_p      (done_nom_mul1),  //input                 \n   .a             (ahxmd_shftd),\n   .b             ({1'b0, m}),\n   .y             ({UNCONNECTED1,shftdXm}),\n   .done          (done_nom_mul2)      //output  reg           \n);\n\n\n\n\nalways @ (posedge clk or negedge rst_n) begin\n  if (rst_n == 1'b0) begin\n    y_red <= {2*NBITS{1'b0}};\n  end\n  else if (done_nom_mul2 == 1'b1) begin\n    y_red <= a_loc[ALOCDEPTH-1] - shftdXm;\n  end\nend\n\n\nalways @ (posedge clk or negedge rst_n) begin\n  if (rst_n == 1'b0) begin\n    done        <= 1'b0;\n  end\n  else begin\n    done_nom_mul2_d <= done_nom_mul2;\n    done            <= done_nom_mul2_d;\n  end\nend\n\n\nassign y_red_sub_m    = y_red - m;\nassign y_red_sub_mx2  = y_red - {m, 1'b0};\n\n\nalways @ (posedge clk or negedge rst_n) begin\n  if (rst_n == 1'b0) begin\n    y <= {NBITS{1'b0}};\n  end\n  else if (done_nom_mul2_d == 1'b1) begin\n    if (y_red_sub_m[NBITS+2] == 1'b1) begin\n      y <= y_red;\n    end\n    else if (y_red_sub_mx2[NBITS+3] == 1'b1) begin\n      y <= y_red_sub_m;\n    end\n    else begin\n      y <= y_red_sub_mx2;\n    end\n  end\nend\n\n\nendmodule\n"]}
{"Instruction": "Please implement the module mod_mul_opt(\ninput               clk,\n  input               rst_n,\n  input               enable_p,\n  input               nmul,\n  input  [NBITS-1 :0] a,\n  input  [NBITS-1 :0] b,\n  input  [NBITS-1 :0] m,\n  input  [NBITS   :0] md,\n  input  [$clog2(NBITS)+1:0]     k,\n  input  [$clog2(NBITS)  :0]     k_shft_ah,     // (k >> 1)  - 1\n  input  [$clog2(NBITS)  :0]     k_shft_ahxmd,  // (k >> 1)  + 1\n  output [NBITS-1 :0] y,\n  output [2*NBITS-1 :0] y_nom_mul,\n  output              done_irq_p,\n  output              done_nom_mul\n););", "Response": ["`timescale 1 ns/1 ps\nmodule mod_mul_opt #(\n  parameter NBITS = 128,\n  parameter PBITS = 0\n\n ) (\n  input               clk,\n  input               rst_n,\n  input               enable_p,\n  input               nmul,\n  input  [NBITS-1 :0] a,\n  input  [NBITS-1 :0] b,\n  input  [NBITS-1 :0] m,\n  input  [NBITS   :0] md,\n  input  [$clog2(NBITS)+1:0]     k,\n  input  [$clog2(NBITS)  :0]     k_shft_ah,     // (k >> 1)  - 1\n  input  [$clog2(NBITS)  :0]     k_shft_ahxmd,  // (k >> 1)  + 1\n  output [NBITS-1 :0] y,\n  output [2*NBITS-1 :0] y_nom_mul,\n  output              done_irq_p,\n  output              done_nom_mul\n);\n\n\n\nnom_mul #(\n  .NBITS (NBITS),\n  .PBITS (0)\n ) u_nom_mul_inst  (\n  .clk           (clk),          //input                 \n  .rst_n         (rst_n),        //input                 \n  .enable_p      (enable_p),     //input                 \n  .a             (a),            //input  [NBITS-1 :0]   \n  .b             (b),            //input  [NBITS-1 :0]   \n  .y             (y_nom_mul),    //output [2*NBITS-1 :0] \n  .done          (done_nom_mul)      //output  reg           \n);\n\nbarrett_red_opt  #(\n  .NBITS (NBITS),\n  .PBITS (0)\n ) u_barrett_red_inst (\n  .clk           (clk),                      //input                   \n  .rst_n         (rst_n),                    //input                   \n  .enable_p      (~nmul & done_nom_mul),     //input                   \n  .a             (y_nom_mul),                //input  [2*NBITS-1 :0]   \n  .m             (m),                        //input  [NBITS-1 :0]     \n  .k             (k),                        //input  [NBITS+15:0]     \n  .k_shft_ah     (k_shft_ah),                        //input  [NBITS+15:0]     \n  .k_shft_ahxmd  (k_shft_ahxmd),                        //input  [NBITS+15:0]     \n  .md            (md),                       //input  [7:0]            \n  .done          (done_barret),               //output reg              \n  .y             (y)                         //)                          //output reg [NBITS-1 :0] \n);\n\nassign done_irq_p = nmul ? done_nom_mul : done_barret;\n\n\n\nendmodule\n"]}
